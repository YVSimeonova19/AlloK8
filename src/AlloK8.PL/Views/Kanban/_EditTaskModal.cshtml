@model TaskUpdateVM

<div class="modal fade" id="taskModal" tabindex="-1" role="dialog" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="modal-title"></h5>
                <button class="close" type="button" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">×</span>
                </button>
            </div>
            <div class="modal-body">
                <form class="forms-sample" asp-controller="Kanban" asp-action="EditTask" method="post">
                    <input type="hidden" asp-for="Id">
                    <input type="hidden" id="projectId" name="ProjectId"
                           value="@ViewContext.RouteData.Values["projectId"]">
                    <div class="row">
                        <!-- Left side: Title, Description, User Assignment -->
                        <div class="col-md-8 border-right">
                            <div class="form-group">
                                <label for="title">@T.TitleModalEditTaskText</label>
                                <input asp-for="Title"
                                       class="form-control"
                                       id="title"
                                       type="text"
                                       placeholder="@T.TitleModalEditTaskText">
                                <span class="text-danger text-small" asp-validation-for="Title"></span>
                            </div>
                            <div class="form-group">
                                <label for="description">@T.DescriptionModalEditTaskText</label>
                                <textarea asp-for="Description"
                                          class="form-control"
                                          id="description"
                                          rows="5"
                                          placeholder="@T.DescriptionModalEditTaskText"></textarea>
                                <span class="text-danger text-small" asp-validation-for="Description"></span>
                            </div>

                            <div class="form-group">
                                <label>@T.AssignUsersLabel</label>
                                <div class="user-search-bar">
                                    <input type="text"
                                           id="userSearchInput"
                                           class="form-control"
                                           placeholder="@T.SearchForUsersPlaceholderText"
                                           autocomplete="off"/>
                                    <div id="validationError" class="invalid-feedback"></div>
                                    <div id="userResults" class="list-group mt-2 user-results-dropdown"></div>
                                </div>

                                <div class="mt-3">
                                    <h6>@T.SelectedUsersToAddTitleText</h6>
                                    <div id="selectedUsers"></div>
                                    <button type="button" id="addUsersButton"
                                            class="btn btn-outline-primary btn-sm mt-3">
                                        @T.AssignUsersLabel
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Right side: Assigned Users, Dates, Priority, and now Labels -->
                        <div class="col-md-4">
                            <div class="form-group">
                                <h6>@T.TaskUsersLabel</h6>
                                <div id="assignedUsers" class="assigned-users-list">
                                    <!-- Loading indicator -->
                                    <div class="text-center py-3">
                                        <div class="spinner-border text-primary" role="status">
                                            <span class="sr-only">@T.LoadingText</span>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="form-group">
                                <label>Labels</label>
                                <div class="label-search-container">
                                    <div id="selectedLabels" class="selected-labels mb-2"></div>
                                    <div class="available-labels-container">
                                        <div id="availableLabels" class="available-labels-list">
                                            <!-- Loading indicator -->
                                            <div class="text-center py-3">
                                                <div class="spinner-border text-primary" role="status">
                                                    <span class="sr-only">Loading...</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="start-date">@T.StartDateModalEditTaskText</label>
                                <input asp-for="StartDate"
                                       class="form-control"
                                       id="start-date"
                                       type="date">
                                <span class="text-danger text-small" asp-validation-for="StartDate"></span>
                            </div>
                            <div class="form-group">
                                <label for="due-date">@T.DueDateModalEditTaskText</label>
                                <input asp-for="DueDate"
                                       class="form-control"
                                       id="due-date"
                                       type="date">
                                <span class="text-danger text-small" asp-validation-for="DueDate"></span>
                            </div>
                            <div class="form-check form-check-flat form-check-primary">
                                <label for="is-priority" class="form-check-label">
                                    <input asp-for="IsPriority"
                                           class="form-check-input"
                                           id="is-priority"
                                           type="checkbox">
                                    @T.IsPriorityCheckLabel
                                    <i class="input-helper"></i>
                                </label>
                            </div>
                        </div>
                    </div>

                    <div class="text-right mt-3">
                        <button class="btn btn-primary" type="submit">
                            @T.SubmitChangesModalEditButtonText
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        const userSearchInput = document.getElementById("userSearchInput");
        const userResults = document.getElementById("userResults");
        const selectedUsersContainer = document.getElementById("selectedUsers");
        const assignedUsersContainer = document.getElementById("assignedUsers");
        const validationError = document.getElementById("validationError");
        const addUsersButton = document.getElementById("addUsersButton");
        let selectedUsers = []; // New users to be added
        let assignedUsers = []; // Currently assigned users

        // Label variables
        const selectedLabelsContainer = document.getElementById("selectedLabels");
        const availableLabelsContainer = document.getElementById("availableLabels");
        let availableLabels = []; // All labels for the project
        let selectedLabels = []; // Selected labels for the task

        // Helper function to extract email from different user object structures
        function getUserEmail(user) {
            if (user.email) return user.email;
            if (user.applicationUser?.email) return user.applicationUser.email;
            if (user.userName) return user.userName;
            return "Unknown email";
        }

        // Function to get the project ID from the URL
        function getProjectIdFromUrl() {
            // Try to extract project ID from URL, assuming it follows the pattern /projects/{projectId}/...
            const urlParts = window.location.pathname.split('/');
            const projectIdIndex = urlParts.indexOf('projects') + 1;

            if (projectIdIndex > 0 && projectIdIndex < urlParts.length) {
                return urlParts[projectIdIndex];
            }

            // Fallback: Look for a hidden input with project ID
            const projectIdInput = document.querySelector('input[name="ProjectId"]');
            if (projectIdInput) {
                return projectIdInput.value;
            }

            // Second fallback: Try to get from the kanban view model
            return document.querySelector('#projectId')?.value || '';
        }

        // Function to determine text color based on background color
        function getTextColor(backgroundColor) {
            if (!backgroundColor) return '#000000';

            // Add # if it's not already there
            if (!backgroundColor.startsWith('#')) {
                backgroundColor = '#' + backgroundColor;
            }

            const color = backgroundColor.replace('#', '');
            const r = parseInt(color.substr(0, 2), 16);
            const g = parseInt(color.substr(2, 2), 16);
            const b = parseInt(color.substr(4, 2), 16);

            const brightness = (r * 0.299 + g * 0.587 + b * 0.114);

            return brightness > 130 ? '#000000' : '#FFFFFF';
        }

        // Load available labels for the project
        async function loadAvailableLabels() {
            try {
                const projectId = getProjectIdFromUrl();
                if (!projectId) {
                    availableLabelsContainer.innerHTML = "<div class='text-center text-muted'>Cannot determine project ID</div>";
                    return;
                }

                const response = await fetch(`/projects/${projectId}/labels/all`);
                if (response.ok) {
                    availableLabels = await response.json();
                    renderAvailableLabels();
                } else {
                    availableLabelsContainer.innerHTML = "<div class='text-center text-muted'>Error loading labels</div>";
                }
            } catch (error) {
                availableLabelsContainer.innerHTML = "<div class='text-center text-muted'>Error loading labels</div>";
            }
        }

        // Load labels for the task
        async function loadTaskLabels(taskId) {
            try {
                const response = await fetch(`/kanban/task/${taskId}/labels`);
                if (response.ok) {
                    selectedLabels = await response.json();
                    renderSelectedLabels();
                }
            } catch (error) {
                // Silently fail - we'll just show no labels
                selectedLabels = [];
                renderSelectedLabels();
            }
        }

        // Render available labels
        function renderAvailableLabels() {
            availableLabelsContainer.innerHTML = "";

            if (availableLabels.length === 0) {
                availableLabelsContainer.innerHTML = "<div class='text-center text-muted'>No labels available</div>";
                return;
            }

            const labelsList = document.createElement("div");
            labelsList.classList.add("available-labels");

            availableLabels.forEach(label => {
                // Skip if the label is already selected
                if (selectedLabels.some(l => l.id === label.id)) {
                    return;
                }

                const labelItem = document.createElement("div");
                labelItem.classList.add("available-label");
                labelItem.dataset.id = label.id;

                const labelBadge = document.createElement("span");
                labelBadge.classList.add("label-badge");
                labelBadge.style.backgroundColor = label.color;
                labelBadge.style.color = getTextColor(label.color);
                labelBadge.textContent = label.title;

                labelItem.appendChild(labelBadge);
                labelItem.addEventListener("click", () => {
                    selectLabel(label);
                });

                labelsList.appendChild(labelItem);
            });

            availableLabelsContainer.appendChild(labelsList);
        }

        // Render selected labels
        function renderSelectedLabels() {
            selectedLabelsContainer.innerHTML = "";

            if (selectedLabels.length === 0) {
                const emptyMessage = document.createElement("div");
                emptyMessage.classList.add("text-muted", "small");
                emptyMessage.textContent = "No labels selected";
                selectedLabelsContainer.appendChild(emptyMessage);
                return;
            }

            selectedLabels.forEach(label => {
                const labelItem = document.createElement("div");
                labelItem.classList.add("selected-label");
                labelItem.dataset.id = label.id;

                const labelBadge = document.createElement("span");
                labelBadge.classList.add("label-badge");
                labelBadge.style.backgroundColor = label.color;
                labelBadge.style.color = getTextColor(label.color);
                labelBadge.textContent = label.title;

                const removeButton = document.createElement("button");
                removeButton.classList.add("remove-label-btn");
                removeButton.innerHTML = "×";
                removeButton.addEventListener("click", function(e) {
                    e.preventDefault();
                    removeLabel(label.id);
                });

                const hiddenInput = document.createElement("input");
                hiddenInput.type = "hidden";
                hiddenInput.name = "LabelIds[]";
                hiddenInput.value = label.id;

                labelItem.appendChild(labelBadge);
                labelItem.appendChild(removeButton);
                labelItem.appendChild(hiddenInput);
                selectedLabelsContainer.appendChild(labelItem);
            });

            // Update available labels display
            renderAvailableLabels();
        }

        // Select a label
        function selectLabel(label) {
            // Check if already selected
            if (selectedLabels.some(l => l.id === label.id)) {
                return;
            }

            // Add to selected labels
            selectedLabels.push(label);

            // Update UI
            renderSelectedLabels();
        }

        // Remove a label
        async function removeLabel(labelId) {
            // Find the label object before removing it from selectedLabels
            const removedLabel = selectedLabels.find(label => label.id === labelId);

            // Remove from selected labels
            selectedLabels = selectedLabels.filter(label => label.id !== labelId);

            // Update UI for selected labels
            renderSelectedLabels();

            // If we found the removed label, add it back to availableLabels
            if (removedLabel) {
                // Make sure it's not already in availableLabels
                if (!availableLabels.some(label => label.id === removedLabel.id)) {
                    availableLabels.push(removedLabel);
                }

                // Re-render the available labels to show the newly available label
                renderAvailableLabels();
            }

            // If the task is already saved, also remove the association in the backend
            const taskId = document.querySelector('#taskModal input[name="Id"]').value;
            if (taskId) {
                try {
                    const response = await fetch(`/kanban/task/${taskId}/labels/${labelId}/remove`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`Failed to remove label: ${response.status}`);
                    }
                } catch (error) {
                    console.error('Error removing label:', error);
                }
            }
        }

        // Load assigned users from the task data
        async function loadAssignedUsers(taskId) {
            try {
                // First get the task data using the GetTask endpoint
                const response = await fetch(`/kanban/task/${taskId}`);
                if (response.ok) {
                    const taskData = await response.json();
                    // Assuming the task data includes users
                    assignedUsers = taskData.users || [];
                    renderAssignedUsers();
                } else {
                    assignedUsersContainer.innerHTML = "<div class='text-center text-muted'>@Html.Raw(@T.ErrorLoadingUsersErrorMessageText)</div>";
                }
            } catch (error) {
                assignedUsersContainer.innerHTML = "<div class='text-center text-muted'>@Html.Raw(@T.ErrorLoadingUsersErrorMessageText)</div>";
            }
        }

        // Function to assign a user to a task
        async function assignUserToTask(taskId, userId) {
            try {
                // Use the dedicated AssignUserToTask endpoint instead of EditTask
                const response = await fetch('/kanban/assign-user', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        taskId: taskId,
                        userId: userId
                    })
                });

                if (!response.ok) {
                    throw new Error(`Failed to assign user: ${response.status}`);
                }

                return true;
            } catch (error) {
                console.error('Error assigning user:', error);
                throw error;
            }
        }

        // Function to remove a user from a task
        async function removeAssignedUser(userId) {
            const taskId = document.querySelector('#taskModal input[name="Id"]').value;
            if (!taskId) {
                alert("@Html.Raw(@T.CannotRemoveUserUnsavedError)");
                return;
            }

            try {
                // Fix POST request by properly sending it with fetch
                const response = await fetch(`/kanban/${taskId}/remove-user/${userId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    // Empty body or add anti-forgery token if needed
                    body: JSON.stringify({})
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Server response:', errorText);
                    throw new Error(`Failed to remove user: ${response.status}`);
                }

                // Remove from our local list
                assignedUsers = assignedUsers.filter(user => user.id !== userId);

                // Update UI
                renderAssignedUsers();

                // Show temporary success message
                const successMsg = document.createElement("div");
                successMsg.classList.add("alert", "alert-success", "mt-2", "mb-2");
                successMsg.textContent = "@Html.Raw(@T.UsersAddedSuccessfullyMessageText)";
                assignedUsersContainer.insertAdjacentElement('beforebegin', successMsg);

                // Remove the message after 3 seconds
                setTimeout(() => {
                    successMsg.remove();
                }, 3000);
            } catch (error) {
                console.error('Error removing user:', error);
                alert("@Html.Raw(@T.FailedToRemoveUserFromTaskErrorMessageText): " + error.message);
            }
        }

        // Render assigned users
        function renderAssignedUsers() {
            assignedUsersContainer.innerHTML = "";

            if (assignedUsers.length === 0) {
                assignedUsersContainer.innerHTML = "<div class='text-center text-muted'>@Html.Raw(@T.NoUsersAssignedText)</div>";
                return;
            }

            assignedUsers.forEach(user => {
                const userItem = document.createElement("div");
                userItem.classList.add("task-user-item");
                userItem.dataset.userId = user.id;

                const userEmail = document.createElement("span");
                userEmail.classList.add("user-email");
                userEmail.textContent = getUserEmail(user);

                // Create hidden input for form submission
                const hiddenInput = document.createElement("input");
                hiddenInput.type = "hidden";
                hiddenInput.name = "Users[]";
                hiddenInput.value = user.id;

                // Add remove button
                const removeButton = document.createElement("button");
                removeButton.classList.add("remove-task-user-btn");
                removeButton.innerHTML = "×";
                removeButton.title = "Remove user";
                removeButton.addEventListener("click", function (e) {
                    e.preventDefault(); // Prevent form submission
                    removeAssignedUser(user.id);
                });

                userItem.appendChild(userEmail);
                userItem.appendChild(removeButton);
                userItem.appendChild(hiddenInput);
                assignedUsersContainer.appendChild(userItem);
            });
        }

        // Search for users as the user types
        userSearchInput.addEventListener("input", async function () {
            const searchTerm = userSearchInput.value.trim();
            hideValidationError();

            if (searchTerm.length >= 1) {
                try {
                    // Get the project ID from the form or the URL
                    const projectId = getProjectIdFromUrl();

                    // Use your new endpoint for searching users
                    const response = await fetch(`/kanban/users/search?email=${searchTerm}&projectId=${projectId}`);
                    if (response.ok) {
                        const users = await response.json();
                        renderUserResults(users);
                    } else {
                        userResults.innerHTML = "<li class='list-group-item'>@Html.Raw(@T.NoUsersFoundMessageText)</li>";
                    }
                } catch (error) {
                    console.error('Error searching users:', error);
                    userResults.innerHTML = "<li class='list-group-item'>@Html.Raw(@T.ErrorSearchingUsers)</li>";
                }
            } else {
                userResults.innerHTML = "";
            }
        });

        // Render the search results
        function renderUserResults(users) {
            userResults.innerHTML = "";

            // Add scrollbar if more than 5 users
            if (users.length > 5) {
                userResults.classList.add("scrollable");
            } else {
                userResults.classList.remove("scrollable");
            }

            users.forEach(user => {
                const userItem = document.createElement("li");
                userItem.classList.add("list-group-item");
                userItem.textContent = getUserEmail(user);
                userItem.dataset.id = user.id;

                // Check if user is already assigned or selected
                const isAssigned = assignedUsers.some(u => u.id === user.id);
                const isSelected = selectedUsers.some(u => u.id === user.id);

                if (isAssigned || isSelected) {
                    userItem.classList.add("disabled");
                    userItem.title = "users already assigned";
                } else {
                    userItem.addEventListener("click", function () {
                        selectUser(user);
                    });
                }

                userResults.appendChild(userItem);
            });
        }

        // Add a user to the selected list
        function selectUser(user) {
            // Check if already selected
            if (selectedUsers.some(u => u.id === user.id)) {
                showValidationError(`${getUserEmail(user)} @Html.Raw(@T.IsAlreadyInYourSelectionText)`);
                return;
            }

            // Check if already assigned
            if (assignedUsers.some(u => u.id === user.id)) {
                showValidationError(`${getUserEmail(user)} @Html.Raw(@T.IsAlreadyAssignedText)`);
                return;
            }

            // Add to selected users
            selectedUsers.push({
                id: user.id,
                email: getUserEmail(user)
            });

            // Create user bubble
            const userBubble = document.createElement("div");
            userBubble.classList.add("selected-user");
            userBubble.dataset.id = user.id;

            const userName = document.createElement("span");
            userName.classList.add("user-name");
            userName.textContent = getUserEmail(user);

            const removeButton = document.createElement("button");
            removeButton.classList.add("remove-user-btn");
            removeButton.textContent = "×";
            removeButton.addEventListener("click", function () {
                removeSelectedUser(user.id);
            });

            userBubble.appendChild(userName);
            userBubble.appendChild(removeButton);
            selectedUsersContainer.appendChild(userBubble);

            // Clear search
            userResults.innerHTML = "";
            userSearchInput.value = "";
        }

        // Remove a user from the selected list
        function removeSelectedUser(userId) {
            selectedUsers = selectedUsers.filter(user => user.id !== userId);
            const userBubble = selectedUsersContainer.querySelector(`.selected-user[data-id='${userId}']`);
            if (userBubble) {
                selectedUsersContainer.removeChild(userBubble);
            }
        }

        // Handle adding users without submitting the entire form
        addUsersButton.addEventListener("click", async function () {
            if (selectedUsers.length === 0) {
                showValidationError("@Html.Raw(@T.PleaseSelectAtLeastOneUserText)");
                return;
            }

            const taskId = document.querySelector('#taskModal input[name="Id"]').value;
            if (!taskId) {
                showValidationError("@Html.Raw(@T.ErrorAddingUserToAnUnsavedTask)");
                return;
            }

            try {
                // Show a loading indicator
                const loadingIndicator = document.createElement("div");
                loadingIndicator.className = "spinner-border spinner-border-sm text-primary ml-2";
                loadingIndicator.setAttribute("role", "status");
                addUsersButton.appendChild(loadingIndicator);
                addUsersButton.disabled = true;

                // For each selected user, make a direct call to the assign endpoint
                for (const user of selectedUsers) {
                    // Check if user is not already in assigned users
                    if (!assignedUsers.some(u => u.id === user.id)) {
                        await fetch('/kanban/assign-user', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                taskId: parseInt(taskId),
                                userId: parseInt(user.id)
                            })
                        });

                        // Add to our local list
                        assignedUsers.push({
                            id: user.id,
                            applicationUser: {
                                email: user.email
                            }
                        });
                    }
                }

                // Clear selected users
                selectedUsers = [];
                selectedUsersContainer.innerHTML = "";

                // Update UI
                renderAssignedUsers();

                // Show success message
                const successMessage = document.createElement("div");
                successMessage.className = "alert alert-success mt-2";
                successMessage.textContent = "@Html.Raw(@T.UsersAddedSuccessfullyMessageText)";
                selectedUsersContainer.appendChild(successMessage);

                // Remove success message after 3 seconds
                setTimeout(() => {
                    if (selectedUsersContainer.contains(successMessage)) {
                        selectedUsersContainer.removeChild(successMessage);
                    }
                }, 3000);
            } catch (error) {
                console.error("Error assigning users:", error);
                showValidationError("Failed to assign users to the task: " + error.message);
            } finally {
                // Remove loading indicator and re-enable button
                addUsersButton.disabled = false;
                const loadingIndicator = addUsersButton.querySelector(".spinner-border");
                if (loadingIndicator) {
                    addUsersButton.removeChild(loadingIndicator);
                }
            }
        });

        // Show validation error
        function showValidationError(message) {
            validationError.textContent = message;
            userSearchInput.classList.add("is-invalid");
            validationError.style.display = "block";
        }

        // Hide validation error
        function hideValidationError() {
            userSearchInput.classList.remove("is-invalid");
            validationError.style.display = "none";
        }

        // Initialize when modal is shown
        $('#taskModal').on('shown.bs.modal', function () {
            const taskId = document.querySelector('#taskModal input[name="Id"]').value;

            // Load labels for the project
            loadAvailableLabels();

            // Only load users and task labels if we have a valid task ID
            if (taskId) {
                loadAssignedUsers(taskId);
                loadTaskLabels(taskId);
            } else {
                // For new tasks, there are no assigned users or labels
                assignedUsersContainer.innerHTML = "<div class='text-center text-muted'>@Html.Raw(@T.NoUsersAssignedText)</div>";
                selectedLabels = [];
                renderSelectedLabels();
            }

            // Reset selected users
            selectedUsers = [];
            selectedUsersContainer.innerHTML = "";
            userSearchInput.value = "";
            userResults.innerHTML = "";
        });

        // Handle the form submission with fetch
        document.querySelector("#taskModal form").addEventListener("submit", async function (e) {
            e.preventDefault();

            let form = e.target;
            let formData = new FormData(form);

            // Add the selected users to the form data
            selectedUsers.forEach((user, index) => {
                // Use Users[] format to match the controller's expectation
                formData.append(`Users[]`, user.id);
            });

            try {
                let response = await fetch(form.action, {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    let updatedTask = await response.json();

                    // Update the task in the UI
                    let taskElement = document.getElementById(`task-${updatedTask.id}`);
                    if (taskElement) {
                        taskElement.querySelector("p").innerText = updatedTask.title;

                        if (updatedTask.isPriority) {
                            taskElement.classList.add("priority-task");
                        } else {
                            taskElement.classList.remove("priority-task");
                        }
                    }

                    // Show success message
                    const successMessage = document.createElement("div");
                    successMessage.classList.add("alert", "alert-success", "mb-3");
                    successMessage.innerHTML = "@Html.Raw(@T.TaskUpdatedSuccessfullyMessageText)";
                    form.prepend(successMessage);

                    // Remove message after 3 seconds
                    setTimeout(() => {
                        successMessage.remove();
                        // Close the modal
                        $("#taskModal").modal("hide");
                    }, 3000);
                } else {
                    let errorData = await response.text();
                    console.error('Failed to update task:', errorData);
                    alert('@Html.Raw(@T.FailedToUpdateTaskText)');
                }
            } catch (error) {
                console.error('Error:', error);
                alert('@Html.Raw(@T.ErrorWhileUpdatingTaskMessageText)');
            }
        });
    });
</script>

<style>
    /* User search styling */
    .user-search-bar {
        position: relative;
        width: 100%;
    }

    #userResults {
        width: 100%;
        border: 1px solid #ddd;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        display: none;
        position: absolute;
        z-index: 1000;
        background-color: white;
    }

    #userResults:not(:empty) {
        display: block;
    }

    #userResults.scrollable {
        max-height: 215px;
        overflow-y: auto;
    }

    .list-group-item {
        padding: 8px 16px;
        cursor: pointer;
    }

    /* User indicator styling for Kanban cards */
    .task-users-indicator {
        margin-top: 4px;
        font-size: 0.8rem;
    }

    .list-group-item:hover {
        background-color: #f8f9fa;
    }

    .list-group-item.disabled {
        background-color: #f0f0f0;
        color: #6c757d;
        cursor: not-allowed;
    }

    #selectedUsers {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        min-height: 50px;
    }

    .selected-user {
        display: flex;
        align-items: center;
        background-color: #e9ecef;
        padding: 4px 12px;
        border-radius: 16px;
    }

    .selected-user .user-name {
        margin-right: 8px;
    }

    .selected-user .remove-user-btn {
        background: none;
        border: none;
        color: #dc3545;
        font-weight: bold;
        cursor: pointer;
        padding: 0 4px;
    }

    .selected-user .remove-user-btn:hover {
        color: #c82333;
    }

    .invalid-feedback {
        display: none;
    }

    /* Assigned users styling */
    .assigned-users-list {
        max-height: 150px;
        overflow-y: auto;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 8px;
        margin-bottom: 16px;
    }

    .task-user-item {
        padding: 8px;
        border-bottom: 1px solid #eee;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .task-user-item:last-child {
        border-bottom: none;
    }

    .user-email {
        font-size: 0.9rem;
        flex-grow: 1;
    }

    .remove-task-user-btn {
        background: none;
        border: none;
        color: #dc3545;
        font-weight: bold;
        font-size: 1.2rem;
        cursor: pointer;
        padding: 0 8px;
        opacity: 0.7;
        transition: opacity 0.2s ease;
    }

    .remove-task-user-btn:hover {
        opacity: 1;
        color: #c82333;
    }

    .border-right {
        border-right: 1px solid #dee2e6;
    }

    .modal-lg {
        max-width: 800px;
    }

    /* Label styling */
    .label-search-container {
        position: relative;
        width: 100%;
    }

    .selected-labels {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        min-height: 40px;
    }

    .selected-label {
        display: flex;
        align-items: center;
        background-color: #f8f9fa;
        padding: 2px 8px;
        border-radius: 16px;
        border: 1px solid #dee2e6;
    }

    .label-badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.85rem;
    }

    .remove-label-btn {
        background: none;
        border: none;
        color: #dc3545;
        font-weight: bold;
        cursor: pointer;
        padding: 0 4px;
        margin-left: 4px;
    }

    .remove-label-btn:hover {
        color: #c82333;
    }

    .available-labels-container {
        margin-top: 8px;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 8px;
        max-height: 150px;
        overflow-y: auto;
    }

    .available-labels {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
    }

    .available-label {
        cursor: pointer;
        border: 1px solid transparent;
        border-radius: 4px;
        padding: 2px;
        transition: border-color 0.2s;
    }

    .available-label:hover {
        border-color: #6c757d;
    }
    
    /* Center vertically the modal window */
    .modal .modal-dialog {
        margin-top: 20px !important;
    }
</style>